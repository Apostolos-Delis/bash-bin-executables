#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
Usage:
  lwt BRANCH_NAME [--agents "api ui tests"] [--base origin/main] [--parent ..]
  lwt --clear [BRANCH_NAME]

Options:
  --agents    Space-separated list of agent worktrees (default: none)
  --base      Base branch for new branches (default: auto-detect origin/main or master)
  --parent    Parent directory for worktrees (default: "..")
  --clear     Remove all worktrees and branches (default: current branch)
  -h, --help  Show this help message

Examples:
  lwt apostolosdelis/mrtg-91-fix-rspec-ci-build-failures
  lwt apostolosdelis/mrtg-91-fix-ci --agents "api ui" --parent ../worktrees
  lwt apostolosdelis/mrtg-91-fix-ci --base origin/develop
  lwt --clear

BRANCH_NAME is the branch name from Linear (copy with "Copy git branch name").

Behavior:
  - Creates a worktree for the ticket branch (main repo stays on trunk):
      <parent>/<repo>-<ticket>  (e.g. ../myrepo-mrtg-91)
  - With --agents, creates additional worktrees:
      <parent>/<repo>-<ticket>-<agent>  (e.g. ../myrepo-mrtg-91-api)
EOF
}

# Handle help before positional args
case "${1:-}" in
  -h|--help) usage; exit 0 ;;
esac

BRANCH=""
AGENTS=""
BASE=""
PARENT=".."
CLEANUP=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    --agents)  AGENTS="${2:-}"; shift 2 ;;
    --base)    BASE="${2:-}"; shift 2 ;;
    --parent)  PARENT="${2:-}"; shift 2 ;;
    --clear|--cleanup) CLEANUP=true; shift ;;
    -h|--help) usage; exit 0 ;;
    -*)
      echo "Unknown arg: $1" >&2
      usage
      exit 1
      ;;
    *)
      BRANCH="$1"; shift ;;
  esac
done

# Ensure we're in a git repo
ROOT="$(git rev-parse --show-toplevel 2>/dev/null || true)"
if [[ -z "$ROOT" ]]; then
  echo "Not inside a git repository." >&2
  exit 1
fi
cd "$ROOT"

REPO_NAME="$(basename "$ROOT")"

# Handle cleanup mode
if [[ "$CLEANUP" == true ]]; then
  # Default to current branch if not specified
  if [[ -z "$BRANCH" ]]; then
    BRANCH=$(git branch --show-current)
  fi

  # Refuse to clear main/master
  if [[ "$BRANCH" == "main" || "$BRANCH" == "master" ]]; then
    echo "Refusing to clear trunk branch: $BRANCH" >&2
    exit 1
  fi

  echo "Cleaning up worktrees and branches for: $BRANCH"
  echo

  # Find and remove all worktrees for this branch (integration + agents)
  while IFS= read -r line; do
    wt_path=$(echo "$line" | awk '{print $1}')
    wt_branch=$(echo "$line" | sed -n 's/.*\[\(.*\)\].*/\1/p')

    if [[ "$wt_branch" == "$BRANCH" || "$wt_branch" == "$BRANCH"-* ]]; then
      echo "Removing worktree: $wt_path ($wt_branch)"
      git worktree remove --force "$wt_path" 2>/dev/null || true
    fi
  done < <(git worktree list)

  # Delete agent branches
  while IFS= read -r agent_branch; do
    if [[ -n "$agent_branch" ]]; then
      echo "Deleting branch: $agent_branch"
      git branch -D "$agent_branch" 2>/dev/null || true
    fi
  done < <(git branch --list "${BRANCH}-*" | sed 's/^[* ]*//')

  # Delete integration branch
  if git show-ref --verify --quiet "refs/heads/${BRANCH}"; then
    echo "Deleting branch: $BRANCH"
    git branch -D "$BRANCH" 2>/dev/null || true
  fi

  git worktree prune
  echo
  echo "Cleanup complete."
  exit 0
fi

if [[ -z "$BRANCH" ]]; then
  echo "Missing BRANCH_NAME" >&2
  usage
  exit 1
fi

# Extract ticket ID from branch name (e.g. "mrtg-91" from "apostolosdelis/mrtg-91-fix-ci")
# Pattern: after the slash, grab project-number before the next dash
AFTER_SLASH="${BRANCH#*/}"
if [[ "$AFTER_SLASH" =~ ^([a-zA-Z]+-[0-9]+) ]]; then
  TICKET="${BASH_REMATCH[1]}"
else
  TICKET="$AFTER_SLASH"
fi

# Determine default base if not provided
if [[ -z "$BASE" ]]; then
  if ORIGIN_HEAD_REF="$(git symbolic-ref -q refs/remotes/origin/HEAD 2>/dev/null)"; then
    BASE="origin/${ORIGIN_HEAD_REF#refs/remotes/origin/}"
  elif git show-ref --verify --quiet refs/remotes/origin/main; then
    BASE="origin/main"
  elif git show-ref --verify --quiet refs/remotes/origin/master; then
    BASE="origin/master"
  else
    BASE="HEAD"
  fi
fi

echo "Repo:      $REPO_NAME"
echo "Branch:    $BRANCH"
echo "Ticket:    $TICKET"
echo "Base:      $BASE"
echo "Agents:    $AGENTS"
echo "Parent:    $PARENT"
echo

# Update refs (safe even if offline)
git fetch origin --prune >/dev/null 2>&1 || true

# Create parent directory if needed
mkdir -p "$PARENT"

# Create worktree for integration branch
INTEG_DIR="${PARENT}/${REPO_NAME}-${TICKET}"

if [[ -e "$INTEG_DIR" ]]; then
  echo "Skip (dir exists): $INTEG_DIR"
else
  if git show-ref --verify --quiet "refs/heads/${BRANCH}"; then
    echo "Adding worktree: $INTEG_DIR  (branch exists: $BRANCH)"
    git worktree add "$INTEG_DIR" "$BRANCH" >/dev/null
  else
    echo "Adding worktree: $INTEG_DIR  (new branch: $BRANCH from $BASE)"
    git worktree add -b "$BRANCH" "$INTEG_DIR" "$BASE" >/dev/null
  fi
fi

# Create agent worktrees
for agent in $AGENTS; do
  agent_branch="${BRANCH}-${agent}"
  wt_dir="${PARENT}/${REPO_NAME}-${TICKET}-${agent}"

  if [[ -e "$wt_dir" ]]; then
    echo "Skip (dir exists): $wt_dir"
    continue
  fi

  if git show-ref --verify --quiet "refs/heads/${agent_branch}"; then
    echo "Adding worktree: $wt_dir  (branch exists: $agent_branch)"
    git worktree add "$wt_dir" "$agent_branch" >/dev/null
  else
    echo "Adding worktree: $wt_dir  (new branch: $agent_branch from $BRANCH)"
    git worktree add -b "$agent_branch" "$wt_dir" "$BRANCH" >/dev/null
  fi
done

echo
echo "Worktrees:"
git worktree list
echo
echo "Next steps:"
echo "  cd $INTEG_DIR"
